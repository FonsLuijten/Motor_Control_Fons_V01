void trace( ) {
  for( int i = 0; i<10; i++){
    int isignal = tracearray[i];
    switch( isignal ){
      case   0: bf.fp   = adc2V; break;
      case   1: bf.fp   = enc2rad; break;
      case   2: bf.fp   = enc2m; break;
      case   3: bf.fp   = Xm1; break;
      case   4: bf.fp   = Xm2; break;
      case   5: bf.fp   = sens; break;
      case   6: bf.fp   = Im1[0]; break;
      case   7: bf.fp   = Im1[1]; break;
      case   8: bf.fp   = Im1[2]; break;
      case   9: bf.fp   = Im1cal[0]; break;
      case  10: bf.fp   = Im1cal[1]; break;
      case  11: bf.fp   = Im1cal[2]; break;
      case  12: bf.fp   = sensCalVal; break;
      case  13: bf.fp   = prbs_gain; break;
      case  14: bf.fp   = prbs_out; break;
      case  15: bf.fp   = ss_phase; break;
      case  16: bf.fp   = ss_fstart; break;
      case  17: bf.fp   = ss_fstep; break;
      case  18: bf.fp   = ss_fend; break;
      case  19: bf.fp   = ss_gain; break;
      case  20: bf.fp   = ss_offset; break;
      case  21: bf.fp   = ss_f; break;
      case  22: bf.fp   = ss_tstart; break;
      case  23: bf.fp   = ss_out; break;
      case  24: bf.fp   = music_gain; break;
      case  25: bf.fp   = music_out; break;
      case  26: bf.fp   = muziek_gain_V; break;
      case  27: bf.fp   = distoff; break;
      case  28: bf.fp   = dist; break;
      case  29: bf.fp   = distcurQ; break;
      case  30: bf.fp   = distcurD; break;
      case  31: bf.fp   = distcurSP; break;
      case  32: bf.fp   = distpos; break;
      case  33: bf.fp   = distposSP; break;
      case  34: bf.fp   = sp1_tstart; break;
      case  35: bf.fp   = sp1_t1; break;
      case  36: bf.fp   = sp1_t2; break;
      case  37: bf.fp   = sp1_t3; break;
      case  38: bf.fp   = sp1_p; break;
      case  39: bf.fp   = sp1_vmax; break;
      case  40: bf.fp   = sp1_amax; break;
      case  41: bf.fp   = sp1_jmax; break;
      case  42: bf.fp   = acc; break;
      case  43: bf.fp   = vel; break;
      case  44: bf.fp   = Xsp1; break;
      case  45: bf.fp   = Xsp2; break;
      case  46: bf.fp   = Xsp1Offs; break;
      case  47: bf.fp   = Xsp2Offs; break;
      case  48: bf.fp   = offsetVelTot; break;
      case  49: bf.fp   = offsetVel; break;
      case  50: bf.fp   = Jload; break;
      case  51: bf.fp   = Xe1; break;
      case  52: bf.fp   = Xe2; break;
      case  53: bf.fp   = PC1out; break;
      case  54: bf.fp   = PC2out; break;
      case  55: bf.fp   = Intout1; break;
      case  56: bf.fp   = Intout2; break;
      case  57: bf.fp   = lastpmechy; break;
      case  58: bf.fp   = lastpmechphi; break;
      case  59: bf.fp   = vmechy; break;
      case  60: bf.fp   = vmechphi; break;
      case  61: bf.fp   = fBW; break;
      case  62: bf.fp   = alpha1; break;
      case  63: bf.fp   = alpha2; break;
      case  64: bf.fp   = fInt; break;
      case  65: bf.fp   = fLP; break;
      case  66: bf.fp   = Kp_PC1; break;
      case  67: bf.fp   = Kp_PC2; break;
      case  68: bf.fp   = velFF; break;
      case  69: bf.fp   = R; break;
      case  70: bf.fp   = Kt1; break;
      case  71: bf.fp   = Isp1dq[0]; break;
      case  72: bf.fp   = Isp1dq[1]; break;
      case  73: bf.fp   = Ie1dq[0]; break;
      case  74: bf.fp   = Ie1dq[1]; break;
      case  75: bf.fp   = Vccout1dq[0]; break;
      case  76: bf.fp   = Vccout1dq[1]; break;
      case  77: bf.fp   = VccFF1dq[0]; break;
      case  78: bf.fp   = VccFF1dq[1]; break;
      case  79: bf.fp   = CC1kp; break;
      case  80: bf.fp   = CC1fInt; break;
      case  81: bf.fp   = V_bus; break;
      case  82: bf.fp   = Im1ab[0]; break;
      case  83: bf.fp   = Im1ab[1]; break;
      case  84: bf.fp   = Im1dq[0]; break;
      case  85: bf.fp   = Im1dq[1]; break;
      case  86: bf.fp   = Vph1ab[0]; break;
      case  87: bf.fp   = Vph1ab[1]; break;
      case  88: bf.fp   = Vph1dq[0]; break;
      case  89: bf.fp   = Vph1dq[1]; break;
      case  90: bf.fp   = Vph1dqOffs[0]; break;
      case  91: bf.fp   = Vph1dqOffs[1]; break;
      case  92: bf.fp   = Vph1[0]; break;
      case  93: bf.fp   = Vph1[1]; break;
      case  94: bf.fp   = Vph1[2]; break;
      case  95: bf.fp   = ThetaEcalAmp; break;
      case  96: bf.fp   = ThetaEcalFreq; break;
      case  97: bf.fp   = ThetaE1; break;
      case  98: bf.fp   = ThetaE1cal; break;
      case  99: bf.fp   = ThetaE1sin; break;
      case 100: bf.fp   = ThetaE1cos; break;
      case 101: bf.fp   = SVM1shift; break;
      case 102: bf.fp   = I_max; break;
      case 103: bf.fp   = V_max; break;
      case 104: bf.fp   = e_max; break;
      case 105: bf.fp   = PWMph1offs[0]; break;
      case 106: bf.fp   = PWMph1offs[1]; break;
      case 107: bf.fp   = PWMph1offs[2]; break;
      case 108: bf.sint = incomingByte; break;
      case 109: bf.sint = outLed; break;
      case 110: bf.sint = outPhA1; break;
      case 111: bf.sint = outPhB1; break;
      case 112: bf.sint = outPhC1; break;
      case 113: bf.sint = outEn1; break;
      case 114: bf.sint = outEnBrake1; break;
      case 115: bf.sint = inA1; break;
      case 116: bf.sint = inB1; break;
      case 117: bf.sint = inZ1; break;
      case 118: bf.sint = inA2; break;
      case 119: bf.sint = inB2; break;
      case 120: bf.sint = inZ2; break;
      case 121: bf.sint = inIA1; break;
      case 122: bf.sint = inIB1; break;
      case 123: bf.sint = inIC1; break;
      case 124: bf.sint = enc1np; break;
      case 125: bf.sint = EncPos1Raw; break;
      case 126: bf.sint = EncPos2Raw; break;
      case 127: bf.sint = IndexFound1; break;
      case 128: bf.sint = IndexFound2; break;
      case 129: bf.sint = sensorValue; break;
      case 130: bf.sint = state; break;
      case 131: bf.sint = stateprev; break;
      case 132: bf.sint = enBrake; break;
      case 133: bf.sint = endistcurQ; break;
      case 134: bf.sint = endistcurD; break;
      case 135: bf.sint = endistcurSP; break;
      case 136: bf.sint = endistpos; break;
      case 137: bf.sint = endistposSP; break;
      case 138: bf.sint = spGO; break;
      case 139: bf.sint = spSET; break;
      case 140: bf.sint = IntegOn; break;
      case 141: bf.sint = npole1; break;
      case 142: bf.sint = enSVM; break;
      case 143: bf.sint = errcode; break;
      case 144: bf.sint = PWMph1[0]; break;
      case 145: bf.sint = PWMph1[1]; break;
      case 146: bf.sint = PWMph1[2]; break;
      case 147: bf.sint = timeremain; break;
      case 148: bf.sint = TET; break;
      case 149: bf.uint = zenddata; break;
      case 150: bf.uint = Nsend; break;
      case 151: bf.uint = sigid; break;
      case 152: bf.uint = Ndownsample; break;
      case 153: bf.uint = downsample; break;
      case 154: bf.uint = ss_n_aver; break;
      case 155: bf.uint = calctime; break;
      case 156: bf.uint = previousTime; break;
      case 157: bf.uint = timePrev; break;
      case 158: bf.uint = curtime; break;
      case 159: bf.uint = curloop; break;
    }
    Serial.write( bf.bin , 4);
  }
}

void setpar( int isignal , binaryFloat bf ) {
  switch( isignal ){
    case   0: adc2V = bf.fp; break;
    case   1: enc2rad = bf.fp; break;
    case   2: enc2m = bf.fp; break;
    case   3: Xm1 = bf.fp; break;
    case   4: Xm2 = bf.fp; break;
    case   5: sens = bf.fp; break;
    case   6: Im1[0] = bf.fp; break;
    case   7: Im1[1] = bf.fp; break;
    case   8: Im1[2] = bf.fp; break;
    case   9: Im1cal[0] = bf.fp; break;
    case  10: Im1cal[1] = bf.fp; break;
    case  11: Im1cal[2] = bf.fp; break;
    case  12: sensCalVal = bf.fp; break;
    case  13: prbs_gain = bf.fp; break;
    case  14: prbs_out = bf.fp; break;
    case  15: ss_phase = bf.fp; break;
    case  16: ss_fstart = bf.fp; break;
    case  17: ss_fstep = bf.fp; break;
    case  18: ss_fend = bf.fp; break;
    case  19: ss_gain = bf.fp; break;
    case  20: ss_offset = bf.fp; break;
    case  21: ss_f = bf.fp; break;
    case  22: ss_tstart = bf.fp; break;
    case  23: ss_out = bf.fp; break;
    case  24: music_gain = bf.fp; break;
    case  25: music_out = bf.fp; break;
    case  26: muziek_gain_V = bf.fp; break;
    case  27: distoff = bf.fp; break;
    case  28: dist = bf.fp; break;
    case  29: distcurQ = bf.fp; break;
    case  30: distcurD = bf.fp; break;
    case  31: distcurSP = bf.fp; break;
    case  32: distpos = bf.fp; break;
    case  33: distposSP = bf.fp; break;
    case  34: sp1_tstart = bf.fp; break;
    case  35: sp1_t1 = bf.fp; break;
    case  36: sp1_t2 = bf.fp; break;
    case  37: sp1_t3 = bf.fp; break;
    case  38: sp1_p = bf.fp; break;
    case  39: sp1_vmax = bf.fp; break;
    case  40: sp1_amax = bf.fp; break;
    case  41: sp1_jmax = bf.fp; break;
    case  42: acc = bf.fp; break;
    case  43: vel = bf.fp; break;
    case  44: Xsp1 = bf.fp; break;
    case  45: Xsp2 = bf.fp; break;
    case  46: Xsp1Offs = bf.fp; break;
    case  47: Xsp2Offs = bf.fp; break;
    case  48: offsetVelTot = bf.fp; break;
    case  49: offsetVel = bf.fp; break;
    case  50: Jload = bf.fp; break;
    case  51: Xe1 = bf.fp; break;
    case  52: Xe2 = bf.fp; break;
    case  53: PC1out = bf.fp; break;
    case  54: PC2out = bf.fp; break;
    case  55: Intout1 = bf.fp; break;
    case  56: Intout2 = bf.fp; break;
    case  57: lastpmechy = bf.fp; break;
    case  58: lastpmechphi = bf.fp; break;
    case  59: vmechy = bf.fp; break;
    case  60: vmechphi = bf.fp; break;
    case  61: fBW = bf.fp; break;
    case  62: alpha1 = bf.fp; break;
    case  63: alpha2 = bf.fp; break;
    case  64: fInt = bf.fp; break;
    case  65: fLP = bf.fp; break;
    case  66: Kp_PC1 = bf.fp; break;
    case  67: Kp_PC2 = bf.fp; break;
    case  68: velFF = bf.fp; break;
    case  69: R = bf.fp; break;
    case  70: Kt1 = bf.fp; break;
    case  71: Isp1dq[0] = bf.fp; break;
    case  72: Isp1dq[1] = bf.fp; break;
    case  73: Ie1dq[0] = bf.fp; break;
    case  74: Ie1dq[1] = bf.fp; break;
    case  75: Vccout1dq[0] = bf.fp; break;
    case  76: Vccout1dq[1] = bf.fp; break;
    case  77: VccFF1dq[0] = bf.fp; break;
    case  78: VccFF1dq[1] = bf.fp; break;
    case  79: CC1kp = bf.fp; break;
    case  80: CC1fInt = bf.fp; break;
    case  81: V_bus = bf.fp; break;
    case  82: Im1ab[0] = bf.fp; break;
    case  83: Im1ab[1] = bf.fp; break;
    case  84: Im1dq[0] = bf.fp; break;
    case  85: Im1dq[1] = bf.fp; break;
    case  86: Vph1ab[0] = bf.fp; break;
    case  87: Vph1ab[1] = bf.fp; break;
    case  88: Vph1dq[0] = bf.fp; break;
    case  89: Vph1dq[1] = bf.fp; break;
    case  90: Vph1dqOffs[0] = bf.fp; break;
    case  91: Vph1dqOffs[1] = bf.fp; break;
    case  92: Vph1[0] = bf.fp; break;
    case  93: Vph1[1] = bf.fp; break;
    case  94: Vph1[2] = bf.fp; break;
    case  95: ThetaEcalAmp = bf.fp; break;
    case  96: ThetaEcalFreq = bf.fp; break;
    case  97: ThetaE1 = bf.fp; break;
    case  98: ThetaE1cal = bf.fp; break;
    case  99: ThetaE1sin = bf.fp; break;
    case 100: ThetaE1cos = bf.fp; break;
    case 101: SVM1shift = bf.fp; break;
    case 102: I_max = bf.fp; break;
    case 103: V_max = bf.fp; break;
    case 104: e_max = bf.fp; break;
    case 105: PWMph1offs[0] = bf.fp; break;
    case 106: PWMph1offs[1] = bf.fp; break;
    case 107: PWMph1offs[2] = bf.fp; break;
    case 108: incomingByte = bf.sint; break;
    case 124: enc1np = bf.sint; break;
    case 125: EncPos1Raw = bf.sint; break;
    case 126: EncPos2Raw = bf.sint; break;
    case 127: IndexFound1 = bf.sint; break;
    case 128: IndexFound2 = bf.sint; break;
    case 129: sensorValue = bf.sint; break;
    case 130: state = bf.sint; break;
    case 131: stateprev = bf.sint; break;
    case 132: enBrake = bf.sint; break;
    case 133: endistcurQ = bf.sint; break;
    case 134: endistcurD = bf.sint; break;
    case 135: endistcurSP = bf.sint; break;
    case 136: endistpos = bf.sint; break;
    case 137: endistposSP = bf.sint; break;
    case 138: spGO = bf.sint; break;
    case 139: spSET = bf.sint; break;
    case 140: IntegOn = bf.sint; break;
    case 141: npole1 = bf.sint; break;
    case 142: enSVM = bf.sint; break;
    case 143: errcode = bf.sint; break;
    case 144: PWMph1[0] = bf.sint; break;
    case 145: PWMph1[1] = bf.sint; break;
    case 146: PWMph1[2] = bf.sint; break;
    case 147: timeremain = bf.sint; break;
    case 148: TET = bf.sint; break;
    case 149: zenddata = bf.uint; break;
    case 150: Nsend = bf.uint; break;
    case 151: sigid = bf.uint; break;
    case 152: Ndownsample = bf.uint; break;
    case 153: downsample = bf.uint; break;
    case 154: ss_n_aver = bf.uint; break;
    case 155: calctime = bf.uint; break;
    case 156: previousTime = bf.uint; break;
    case 157: timePrev = bf.uint; break;
    case 158: curtime = bf.uint; break;
    case 159: curloop = bf.uint; break;
  }
}

void printSignals( unsigned int selected ) {
  char *signalNames[] = { "adc2V", "enc2rad", "enc2m", "Xm1", "Xm2", "sens", "Im1[0]", "Im1[1]", "Im1[2]", "Im1cal[0]", "Im1cal[1]", "Im1cal[2]", "sensCalVal", "prbs_gain", "prbs_out", "ss_phase", "ss_fstart", "ss_fstep", "ss_fend", "ss_gain", "ss_offset", "ss_f", "ss_tstart", "ss_out", "music_gain", "music_out", "muziek_gain_V", "distoff", "dist", "distcurQ", "distcurD", "distcurSP", "distpos", "distposSP", "sp1_tstart", "sp1_t1", "sp1_t2", "sp1_t3", "sp1_p", "sp1_vmax", "sp1_amax", "sp1_jmax", "acc", "vel", "Xsp1", "Xsp2", "Xsp1Offs", "Xsp2Offs", "offsetVelTot", "offsetVel", "Jload", "Xe1", "Xe2", "PC1out", "PC2out", "Intout1", "Intout2", "lastpmechy", "lastpmechphi", "vmechy", "vmechphi", "fBW", "alpha1", "alpha2", "fInt", "fLP", "Kp_PC1", "Kp_PC2", "velFF", "R", "Kt1", "Isp1dq[0]", "Isp1dq[1]", "Ie1dq[0]", "Ie1dq[1]", "Vccout1dq[0]", "Vccout1dq[1]", "VccFF1dq[0]", "VccFF1dq[1]", "CC1kp", "CC1fInt", "V_bus", "Im1ab[0]", "Im1ab[1]", "Im1dq[0]", "Im1dq[1]", "Vph1ab[0]", "Vph1ab[1]", "Vph1dq[0]", "Vph1dq[1]", "Vph1dqOffs[0]", "Vph1dqOffs[1]", "Vph1[0]", "Vph1[1]", "Vph1[2]", "ThetaEcalAmp", "ThetaEcalFreq", "ThetaE1", "ThetaE1cal", "ThetaE1sin", "ThetaE1cos", "SVM1shift", "I_max", "V_max", "e_max", "PWMph1offs[0]", "PWMph1offs[1]", "PWMph1offs[2]", "incomingByte", "outLed", "outPhA1", "outPhB1", "outPhC1", "outEn1", "outEnBrake1", "inA1", "inB1", "inZ1", "inA2", "inB2", "inZ2", "inIA1", "inIB1", "inIC1", "enc1np", "EncPos1Raw", "EncPos2Raw", "IndexFound1", "IndexFound2", "sensorValue", "state", "stateprev", "enBrake", "endistcurQ", "endistcurD", "endistcurSP", "endistpos", "endistposSP", "spGO", "spSET", "IntegOn", "npole1", "enSVM", "errcode", "PWMph1[0]", "PWMph1[1]", "PWMph1[2]", "timeremain", "TET", "zenddata", "Nsend", "sigid", "Ndownsample", "downsample", "ss_n_aver", "calctime", "previousTime", "timePrev", "curtime", "curloop",  };
  char *signalTypes[] = { "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "I", "I", "I", "I", "I", "I", "I", "I", "I", "I", "I",  };
  char *signalSizes[] = { "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "3;0", "3;0", "3;0", "3;0", "3;0", "3;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "2;0", "2;0", "2;0", "2;0", "2;0", "2;0", "2;0", "2;0", "0;0", "0;0", "0;0", "2;0", "2;0", "2;0", "2;0", "2;0", "2;0", "2;0", "2;0", "2;0", "2;0", "3;0", "3;0", "3;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "3;0", "3;0", "3;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "3;0", "3;0", "3;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0",  };
  int imax = 10;
  switch(selected){
    case 0: imax = 160; break;
  }
  for ( int i = 0; i < imax; i++) {
    Serial.println( signalNames[i] );
    Serial.println( signalTypes[i] );
    Serial.println( signalSizes[i] );
  }
  Nsend = 0;
  getsignalnames = 1;
}
