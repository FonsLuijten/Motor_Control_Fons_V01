void trace( ) {
  for( int i = 0; i<10; i++){
    int isignal = tracearray[i];
    switch( isignal ){
      case   0: bf.fp   = adc2V; break;
      case   1: bf.fp   = enc2rad; break;
      case   2: bf.fp   = enc2m; break;
      case   3: bf.fp   = penc1; break;
      case   4: bf.fp   = penc2; break;
      case   5: bf.fp   = y; break;
      case   6: bf.fp   = sens; break;
      case   7: bf.fp   = Im1[0]; break;
      case   8: bf.fp   = Im1[1]; break;
      case   9: bf.fp   = Im1[2]; break;
      case  10: bf.fp   = Im1cal[0]; break;
      case  11: bf.fp   = Im1cal[1]; break;
      case  12: bf.fp   = Im1cal[2]; break;
      case  13: bf.fp   = sensCalVal; break;
      case  14: bf.fp   = ss_phase; break;
      case  15: bf.fp   = ss_fstart; break;
      case  16: bf.fp   = ss_fstep; break;
      case  17: bf.fp   = ss_fend; break;
      case  18: bf.fp   = ss_gain; break;
      case  19: bf.fp   = ss_offset; break;
      case  20: bf.fp   = ss_f; break;
      case  21: bf.fp   = ss_tstart; break;
      case  22: bf.fp   = ss_out; break;
      case  23: bf.fp   = rpos1; break;
      case  24: bf.fp   = rpos2; break;
      case  25: bf.fp   = r; break;
      case  26: bf.fp   = acc; break;
      case  27: bf.fp   = vel; break;
      case  28: bf.fp   = dist; break;
      case  29: bf.fp   = cursp; break;
      case  30: bf.fp   = Iout; break;
      case  31: bf.fp   = velFF; break;
      case  32: bf.fp   = R; break;
      case  33: bf.fp   = offsetVelTot; break;
      case  34: bf.fp   = offsetVel; break;
      case  35: bf.fp   = Jload; break;
      case  36: bf.fp   = mechcontout; break;
      case  37: bf.fp   = PC1out; break;
      case  38: bf.fp   = PC2out; break;
      case  39: bf.fp   = Intout1; break;
      case  40: bf.fp   = Intout2; break;
      case  41: bf.fp   = muziek_gain; break;
      case  42: bf.fp   = muziek_gain_V; break;
      case  43: bf.fp   = distval; break;
      case  44: bf.fp   = distoff; break;
      case  45: bf.fp   = emechy; break;
      case  46: bf.fp   = emechphi; break;
      case  47: bf.fp   = lastpmechy; break;
      case  48: bf.fp   = lastpmechphi; break;
      case  49: bf.fp   = vmechy; break;
      case  50: bf.fp   = vmechphi; break;
      case  51: bf.fp   = fBW; break;
      case  52: bf.fp   = alpha1; break;
      case  53: bf.fp   = alpha2; break;
      case  54: bf.fp   = fInt; break;
      case  55: bf.fp   = fLP; break;
      case  56: bf.fp   = Kp_PC1; break;
      case  57: bf.fp   = Kp_PC2; break;
      case  58: bf.fp   = k1; break;
      case  59: bf.fp   = k2; break;
      case  60: bf.fp   = k3; break;
      case  61: bf.fp   = k4; break;
      case  62: bf.fp   = Kt; break;
      case  63: bf.fp   = npole1; break;
      case  64: bf.fp   = e; break;
      case  65: bf.fp   = Icontout; break;
      case  66: bf.fp   = Vout; break;
      case  67: bf.fp   = fIntCur; break;
      case  68: bf.fp   = Icontgain; break;
      case  69: bf.fp   = V_bus; break;
      case  70: bf.fp   = Im1ab[0]; break;
      case  71: bf.fp   = Im1ab[1]; break;
      case  72: bf.fp   = Im1dq[0]; break;
      case  73: bf.fp   = Im1dq[1]; break;
      case  74: bf.fp   = Vph1ab[0]; break;
      case  75: bf.fp   = Vph1ab[1]; break;
      case  76: bf.fp   = Vph1dq[0]; break;
      case  77: bf.fp   = Vph1dq[1]; break;
      case  78: bf.fp   = Vph1[0]; break;
      case  79: bf.fp   = Vph1[1]; break;
      case  80: bf.fp   = Vph1[2]; break;
      case  81: bf.fp   = ThetaE1; break;
      case  82: bf.fp   = ThetaE1sin; break;
      case  83: bf.fp   = ThetaE1cos; break;
      case  84: bf.fp   = I_max; break;
      case  85: bf.fp   = V_max; break;
      case  86: bf.fp   = PWMph1offs[0]; break;
      case  87: bf.fp   = PWMph1offs[1]; break;
      case  88: bf.fp   = PWMph1offs[2]; break;
      case  89: bf.sint = test1; break;
      case  90: bf.sint = test2; break;
      case  91: bf.sint = test3; break;
      case  92: bf.sint = incomingByte; break;
      case  93: bf.sint = outLed; break;
      case  94: bf.sint = outPhA1; break;
      case  95: bf.sint = outPhB1; break;
      case  96: bf.sint = outPhC1; break;
      case  97: bf.sint = inA1; break;
      case  98: bf.sint = inB1; break;
      case  99: bf.sint = inZ1; break;
      case 100: bf.sint = inA2; break;
      case 101: bf.sint = inB2; break;
      case 102: bf.sint = inZ2; break;
      case 103: bf.sint = inIA1; break;
      case 104: bf.sint = inIB1; break;
      case 105: bf.sint = inIC1; break;
      case 106: bf.sint = EncPos1Raw; break;
      case 107: bf.sint = EncPos2Raw; break;
      case 108: bf.sint = sensorValue; break;
      case 109: bf.sint = state; break;
      case 110: bf.sint = PCstate; break;
      case 111: bf.sint = EnStateFB; break;
      case 112: bf.sint = spGO; break;
      case 113: bf.sint = IntegOn; break;
      case 114: bf.sint = errcode; break;
      case 115: bf.sint = PWMph1[0]; break;
      case 116: bf.sint = PWMph1[1]; break;
      case 117: bf.sint = PWMph1[2]; break;
      case 118: bf.sint = timeremain; break;
      case 119: bf.sint = TET; break;
      case 120: bf.uint = zenddata; break;
      case 121: bf.uint = Nsend; break;
      case 122: bf.uint = sigid; break;
      case 123: bf.uint = Ndownsample; break;
      case 124: bf.uint = downsample; break;
      case 125: bf.uint = ss_n_aver; break;
      case 126: bf.uint = ContSelect; break;
      case 127: bf.uint = calctime; break;
      case 128: bf.uint = previousTime; break;
      case 129: bf.uint = timePrev; break;
      case 130: bf.uint = curtime; break;
      case 131: bf.uint = curloop; break;
    }
    Serial.write( bf.bin , 4);
  }
}

void setpar( int isignal , binaryFloat bf ) {
  switch( isignal ){
    case   0: adc2V = bf.fp; break;
    case   1: enc2rad = bf.fp; break;
    case   2: enc2m = bf.fp; break;
    case   3: penc1 = bf.fp; break;
    case   4: penc2 = bf.fp; break;
    case   5: y = bf.fp; break;
    case   6: sens = bf.fp; break;
    case   7: Im1[0] = bf.fp; break;
    case   8: Im1[1] = bf.fp; break;
    case   9: Im1[2] = bf.fp; break;
    case  10: Im1cal[0] = bf.fp; break;
    case  11: Im1cal[1] = bf.fp; break;
    case  12: Im1cal[2] = bf.fp; break;
    case  13: sensCalVal = bf.fp; break;
    case  14: ss_phase = bf.fp; break;
    case  15: ss_fstart = bf.fp; break;
    case  16: ss_fstep = bf.fp; break;
    case  17: ss_fend = bf.fp; break;
    case  18: ss_gain = bf.fp; break;
    case  19: ss_offset = bf.fp; break;
    case  20: ss_f = bf.fp; break;
    case  21: ss_tstart = bf.fp; break;
    case  22: ss_out = bf.fp; break;
    case  23: rpos1 = bf.fp; break;
    case  24: rpos2 = bf.fp; break;
    case  25: r = bf.fp; break;
    case  26: acc = bf.fp; break;
    case  27: vel = bf.fp; break;
    case  28: dist = bf.fp; break;
    case  29: cursp = bf.fp; break;
    case  30: Iout = bf.fp; break;
    case  31: velFF = bf.fp; break;
    case  32: R = bf.fp; break;
    case  33: offsetVelTot = bf.fp; break;
    case  34: offsetVel = bf.fp; break;
    case  35: Jload = bf.fp; break;
    case  36: mechcontout = bf.fp; break;
    case  37: PC1out = bf.fp; break;
    case  38: PC2out = bf.fp; break;
    case  39: Intout1 = bf.fp; break;
    case  40: Intout2 = bf.fp; break;
    case  41: muziek_gain = bf.fp; break;
    case  42: muziek_gain_V = bf.fp; break;
    case  43: distval = bf.fp; break;
    case  44: distoff = bf.fp; break;
    case  45: emechy = bf.fp; break;
    case  46: emechphi = bf.fp; break;
    case  47: lastpmechy = bf.fp; break;
    case  48: lastpmechphi = bf.fp; break;
    case  49: vmechy = bf.fp; break;
    case  50: vmechphi = bf.fp; break;
    case  51: fBW = bf.fp; break;
    case  52: alpha1 = bf.fp; break;
    case  53: alpha2 = bf.fp; break;
    case  54: fInt = bf.fp; break;
    case  55: fLP = bf.fp; break;
    case  56: Kp_PC1 = bf.fp; break;
    case  57: Kp_PC2 = bf.fp; break;
    case  58: k1 = bf.fp; break;
    case  59: k2 = bf.fp; break;
    case  60: k3 = bf.fp; break;
    case  61: k4 = bf.fp; break;
    case  62: Kt = bf.fp; break;
    case  63: npole1 = bf.fp; break;
    case  64: e = bf.fp; break;
    case  65: Icontout = bf.fp; break;
    case  66: Vout = bf.fp; break;
    case  67: fIntCur = bf.fp; break;
    case  68: Icontgain = bf.fp; break;
    case  69: V_bus = bf.fp; break;
    case  70: Im1ab[0] = bf.fp; break;
    case  71: Im1ab[1] = bf.fp; break;
    case  72: Im1dq[0] = bf.fp; break;
    case  73: Im1dq[1] = bf.fp; break;
    case  74: Vph1ab[0] = bf.fp; break;
    case  75: Vph1ab[1] = bf.fp; break;
    case  76: Vph1dq[0] = bf.fp; break;
    case  77: Vph1dq[1] = bf.fp; break;
    case  78: Vph1[0] = bf.fp; break;
    case  79: Vph1[1] = bf.fp; break;
    case  80: Vph1[2] = bf.fp; break;
    case  81: ThetaE1 = bf.fp; break;
    case  82: ThetaE1sin = bf.fp; break;
    case  83: ThetaE1cos = bf.fp; break;
    case  84: I_max = bf.fp; break;
    case  85: V_max = bf.fp; break;
    case  86: PWMph1offs[0] = bf.fp; break;
    case  87: PWMph1offs[1] = bf.fp; break;
    case  88: PWMph1offs[2] = bf.fp; break;
    case  89: test1 = bf.sint; break;
    case  90: test2 = bf.sint; break;
    case  91: test3 = bf.sint; break;
    case  92: incomingByte = bf.sint; break;
    case 106: EncPos1Raw = bf.sint; break;
    case 107: EncPos2Raw = bf.sint; break;
    case 108: sensorValue = bf.sint; break;
    case 109: state = bf.sint; break;
    case 110: PCstate = bf.sint; break;
    case 111: EnStateFB = bf.sint; break;
    case 112: spGO = bf.sint; break;
    case 113: IntegOn = bf.sint; break;
    case 114: errcode = bf.sint; break;
    case 115: PWMph1[0] = bf.sint; break;
    case 116: PWMph1[1] = bf.sint; break;
    case 117: PWMph1[2] = bf.sint; break;
    case 118: timeremain = bf.sint; break;
    case 119: TET = bf.sint; break;
    case 120: zenddata = bf.uint; break;
    case 121: Nsend = bf.uint; break;
    case 122: sigid = bf.uint; break;
    case 123: Ndownsample = bf.uint; break;
    case 124: downsample = bf.uint; break;
    case 125: ss_n_aver = bf.uint; break;
    case 126: ContSelect = bf.uint; break;
    case 127: calctime = bf.uint; break;
    case 128: previousTime = bf.uint; break;
    case 129: timePrev = bf.uint; break;
    case 130: curtime = bf.uint; break;
    case 131: curloop = bf.uint; break;
  }
}

void printSignals( unsigned int selected ) {
  char *signalNames[] = { "adc2V", "enc2rad", "enc2m", "penc1", "penc2", "y", "sens", "Im1[0]", "Im1[1]", "Im1[2]", "Im1cal[0]", "Im1cal[1]", "Im1cal[2]", "sensCalVal", "ss_phase", "ss_fstart", "ss_fstep", "ss_fend", "ss_gain", "ss_offset", "ss_f", "ss_tstart", "ss_out", "rpos1", "rpos2", "r", "acc", "vel", "dist", "cursp", "Iout", "velFF", "R", "offsetVelTot", "offsetVel", "Jload", "mechcontout", "PC1out", "PC2out", "Intout1", "Intout2", "muziek_gain", "muziek_gain_V", "distval", "distoff", "emechy", "emechphi", "lastpmechy", "lastpmechphi", "vmechy", "vmechphi", "fBW", "alpha1", "alpha2", "fInt", "fLP", "Kp_PC1", "Kp_PC2", "k1", "k2", "k3", "k4", "Kt", "npole1", "e", "Icontout", "Vout", "fIntCur", "Icontgain", "V_bus", "Im1ab[0]", "Im1ab[1]", "Im1dq[0]", "Im1dq[1]", "Vph1ab[0]", "Vph1ab[1]", "Vph1dq[0]", "Vph1dq[1]", "Vph1[0]", "Vph1[1]", "Vph1[2]", "ThetaE1", "ThetaE1sin", "ThetaE1cos", "I_max", "V_max", "PWMph1offs[0]", "PWMph1offs[1]", "PWMph1offs[2]", "test1", "test2", "test3", "incomingByte", "outLed", "outPhA1", "outPhB1", "outPhC1", "inA1", "inB1", "inZ1", "inA2", "inB2", "inZ2", "inIA1", "inIB1", "inIC1", "EncPos1Raw", "EncPos2Raw", "sensorValue", "state", "PCstate", "EnStateFB", "spGO", "IntegOn", "errcode", "PWMph1[0]", "PWMph1[1]", "PWMph1[2]", "timeremain", "TET", "zenddata", "Nsend", "sigid", "Ndownsample", "downsample", "ss_n_aver", "ContSelect", "calctime", "previousTime", "timePrev", "curtime", "curloop",  };
  char *signalTypes[] = { "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "i", "I", "I", "I", "I", "I", "I", "I", "I", "I", "I", "I", "I", "I",  };
  char *signalSizes[] = { "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "3;0", "3;0", "3;0", "3;0", "3;0", "3;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "2;0", "2;0", "2;0", "2;0", "2;0", "2;0", "2;0", "2;0", "3;0", "3;0", "3;0", "0;0", "0;0", "0;0", "0;0", "0;0", "3;0", "3;0", "3;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "3;0", "3;0", "3;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0", "0;0",  };
  int imax = 10;
  switch(selected){
    case 0: imax = 132; break;
  }
  for ( int i = 0; i < imax; i++) {
    Serial.println( signalNames[i] );
    Serial.println( signalTypes[i] );
    Serial.println( signalSizes[i] );
  }
  Nsend = 0;
  getsignalnames = 1;
}
